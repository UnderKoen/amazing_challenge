package parser;

import java_cup.runtime.Scanner;
import java_cup.runtime.SymbolFactory;
import java.util.List;
import java.util.ArrayList;
import nl.underkoen.amazing_challenge.components.*;

class Parser;

terminal SPACE, NEW_LINE;
terminal LPAREN, RPAREN;
terminal AND, OR, NOT, IMPLICATION, XNOR;
terminal ASSIGN, USE;

terminal Boolean BOOLEAN;
terminal String VARIABLE;

non terminal Program program;
non terminal ProgramBlock programBlock;
non terminal Used used;
non terminal List<Statement> statements;
non terminal Statement statement;
non terminal Statement assignment;
non terminal Expression expression;

precedence left AND, OR, IMPLICATION, XNOR, NOT;
precedence left SPACE;

program ::= used:u NEW_LINE programBlock:p {: RESULT = new Program(u, p); :};

programBlock ::= statements:sl {: RESULT = new ProgramBlock(sl); :};

used ::= USE SPACE VARIABLE:v {: RESULT = new Used(v); :}
      |  used:u SPACE VARIABLE:v {: RESULT = u.add(v); :};

statements ::= statements:sl statement:s NEW_LINE       {: sl.add(s); RESULT = sl; :}
            |                                           {: RESULT = new ArrayList<Statement>(); :};

statement ::= assignment:a      {: RESULT = a; :}
           |  expression:e      {: RESULT = e; :};

assignment ::= VARIABLE:n SPACE ASSIGN SPACE expression:e {: RESULT = Statement.assign(n, e); :};

expression ::= expression:e1 SPACE AND SPACE expression:e2          {: RESULT = Expression.and(e1, e2); :}
            |  expression:e1 SPACE OR SPACE expression:e2           {: RESULT = Expression.or(e1, e2); :}
            |  expression:e1 SPACE IMPLICATION SPACE expression:e2  {: RESULT = Expression.implication(e1, e2); :}
            |  expression:e1 SPACE XNOR SPACE expression:e2         {: RESULT = Expression.xnor(e1, e2); :}
            |  NOT SPACE expression:e1                              {: RESULT = Expression.not(e1); :}
            |  LPAREN expression:e1 RPAREN                          {: RESULT = e1; :}
            |  BOOLEAN:n                                            {: RESULT = Expression.bool(n); :}
            |  VARIABLE:n                                           {: RESULT = Expression.variable(n);; :};